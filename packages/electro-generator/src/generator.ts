/**
 * Code Generator — produces preload scripts, bridge types, and context types.
 *
 * Takes a ScanResult + window definitions and emits generated files.
 * Uses PolicyEngine for deny-by-default per-window filtering.
 */

import { dirname, join, relative } from "node:path";
import type { WindowDefinition } from "@cordy/electro";
import { PolicyEngine } from "@cordy/electro";
import type { GeneratedFile, ScannedFeature, ScanResult } from "./types";

// ── Constants ───────────────────────────────────────────────────────

const HEADER = "// Auto-generated by Electro codegen. Do not edit.\n";

/** Quote a property key if it's not a valid JS identifier. */
function q(name: string): string {
    return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name) ? name : `"${name}"`;
}

// ── Preload generator ───────────────────────────────────────────────

/**
 * Build the IPC stub expression for a single method.
 * Format: `(...args: unknown[]) => ipcRenderer.invoke("feature:service:method", ...args)`
 */
function methodStub(featureId: string, serviceId: string, method: string): string {
    const channel = `${featureId}:${serviceId}:${method}`;
    return `(...args: unknown[]) => ipcRenderer.invoke("${channel}", ...args)`;
}

/**
 * Generate a preload script for a specific window.
 *
 * Structure: `window.electro.{featureId}.{serviceId}.{method}()`
 * Only EXPOSED scope services are included.
 */
function generatePreload(
    windowName: string,
    features: ScannedFeature[],
    policy: PolicyEngine,
    preloadExtension?: string,
): GeneratedFile {
    const allowedFeatures = features.filter((f) => policy.canAccess(windowName, f.id));

    // Filter to exposed services only
    const featureEntries: string[] = [];

    for (const feature of allowedFeatures) {
        const exposedServices = feature.services.filter((s) => s.scope === "exposed");
        if (exposedServices.length === 0) {
            // Generate empty namespace for allowed features with no exposed services
            featureEntries.push(`    ${q(feature.id)}: {},`);
            continue;
        }

        const serviceEntries: string[] = [];
        for (const service of exposedServices) {
            if (service.methods.length === 0) {
                serviceEntries.push(`        ${q(service.id)}: {},`);
                continue;
            }
            const methodEntries = service.methods
                .map((m) => `            ${q(m)}: ${methodStub(feature.id, service.id, m)},`)
                .join("\n");
            serviceEntries.push(`        ${q(service.id)}: {\n${methodEntries}\n        },`);
        }

        featureEntries.push(`    ${q(feature.id)}: {\n${serviceEntries.join("\n")}\n    },`);
    }

    const bridgeObject = featureEntries.length > 0 ? `{\n${featureEntries.join("\n")}\n}` : "{}";

    let content = `${HEADER}
import { contextBridge, ipcRenderer } from "electron";

contextBridge.exposeInMainWorld("electro", ${bridgeObject});
`;

    // Append user extension import if specified
    if (preloadExtension) {
        content += `\n// User extension\nimport "${preloadExtension}";\n`;
    }

    return {
        path: `generated/preload/${windowName}.gen.ts`,
        content,
    };
}

// ── Bridge types generator ──────────────────────────────────────────

/**
 * Generate bridge type declarations for a specific window.
 * Makes `window.electro` type-safe in the renderer.
 */
function generateBridgeTypes(windowName: string, features: ScannedFeature[], policy: PolicyEngine): GeneratedFile {
    const allowedFeatures = features.filter((f) => policy.canAccess(windowName, f.id));

    const featureTypes: string[] = [];

    for (const feature of allowedFeatures) {
        const exposedServices = feature.services.filter((s) => s.scope === "exposed");
        if (exposedServices.length === 0) {
            featureTypes.push(`        ${q(feature.id)}: Record<string, never>;`);
            continue;
        }

        const serviceTypes: string[] = [];
        for (const service of exposedServices) {
            if (service.methods.length === 0) {
                serviceTypes.push(`            ${q(service.id)}: Record<string, never>;`);
                continue;
            }
            const methodTypes = service.methods
                .map((m) => `                ${q(m)}(...args: unknown[]): Promise<unknown>;`)
                .join("\n");
            serviceTypes.push(`            ${q(service.id)}: {\n${methodTypes}\n            };`);
        }

        featureTypes.push(`        ${q(feature.id)}: {\n${serviceTypes.join("\n")}\n        };`);
    }

    const interfaceBody = featureTypes.length > 0 ? `{\n${featureTypes.join("\n")}\n    }` : "Record<string, never>";

    const content = `${HEADER}
export interface ElectroBridge ${interfaceBody}

declare global {
    interface Window {
        electro: ElectroBridge;
    }
}
`;

    return {
        path: `generated/windows/${windowName}.bridge.d.ts`,
        content,
    };
}

// ── Feature types generator ─────────────────────────────────────────

/** Calculate the import path from the generated env types file to a source file. */
function toImportPath(envTypesDir: string, sourceFilePath: string): string {
    const outputFile = join(envTypesDir, "electro-env.d.ts");
    const rel = relative(dirname(outputFile), sourceFilePath);
    // Remove .ts extension, ensure starts with . or ..
    const importPath = rel.replace(/\.ts$/, "");
    return importPath.startsWith(".") ? importPath : `./${importPath}`;
}

const FEATURE_TYPES_HEADER = `// Auto-generated by Electro codegen. Do not edit.
// Feature context types — provides IDE completions for getService/getTask/getFeature.

export {};

/* ── Utility types ────────────────────────────────────── */
type _SvcApi<T> = T extends { api(): infer R } ? NonNullable<R> : never;
type _TaskPayload<T> = T extends { start(payload?: infer P): any } ? P : void;
type _EventPayload<T> = T extends { payload(): infer P } ? P : unknown;
`;

/**
 * Generate feature type declarations for the main process.
 * Emits a single FeatureMap interface with per-feature entries for
 * services, tasks, and dependencies. Uses typeof import() for full type inference.
 */
function generateWindowTypes(windows: readonly WindowDefinition[]): string {
    if (windows.length === 0) return "";

    const entries: string[] = [];
    for (const win of windows) {
        const windowType = win.type ?? "base-window";
        const electronType =
            windowType === "browser-window" ? 'import("electron").BrowserWindow' : 'import("electron").BaseWindow';
        entries.push(`        "${win.name}": ${electronType};`);
    }

    return `\n    interface WindowMap {\n${entries.join("\n")}\n    }\n`;
}

function generateFeatureTypes(
    features: ScannedFeature[],
    srcDir: string,
    windows: readonly WindowDefinition[],
): GeneratedFile {
    const seenFeatures = new Set<string>();
    const featureBlocks: string[] = [];
    const svcOwnerEntries: string[] = [];
    const taskOwnerEntries: string[] = [];

    for (const feature of features) {
        if (seenFeatures.has(feature.id)) {
            console.warn(`[generator] Duplicate feature id "${feature.id}" — first wins`);
            continue;
        }
        seenFeatures.add(feature.id);

        // Services (deduplicate within feature)
        const seenServices = new Set<string>();
        const serviceEntries: string[] = [];
        for (const svc of feature.services) {
            if (seenServices.has(svc.id)) {
                console.warn(`[generator] Duplicate service id "${svc.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenServices.add(svc.id);

            // Owner map entry
            svcOwnerEntries.push(`        "${svc.id}": "${feature.id}";`);

            if (svc.exported) {
                const importPath = toImportPath(srcDir, svc.filePath);
                serviceEntries.push(
                    `                "${svc.id}": _SvcApi<typeof import("${importPath}").${svc.varName}>;`,
                );
            } else {
                serviceEntries.push(`                "${svc.id}": unknown;`);
            }
        }

        // Tasks (deduplicate within feature)
        const seenTasks = new Set<string>();
        const taskEntries: string[] = [];
        for (const task of feature.tasks) {
            if (seenTasks.has(task.id)) {
                console.warn(`[generator] Duplicate task id "${task.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenTasks.add(task.id);

            // Owner map entry
            taskOwnerEntries.push(`        "${task.id}": "${feature.id}";`);

            if (task.exported) {
                const importPath = toImportPath(srcDir, task.filePath);
                taskEntries.push(
                    `                "${task.id}": _TaskPayload<typeof import("${importPath}").${task.varName}>;`,
                );
            } else {
                taskEntries.push(`                "${task.id}": void;`);
            }
        }

        // Events (deduplicate within feature)
        const seenEvents = new Set<string>();
        const eventEntries: string[] = [];
        for (const evt of feature.events ?? []) {
            if (seenEvents.has(evt.id)) {
                console.warn(`[generator] Duplicate event id "${evt.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenEvents.add(evt.id);

            if (evt.exported) {
                const importPath = toImportPath(srcDir, evt.filePath);
                eventEntries.push(
                    `                "${evt.id}": _EventPayload<typeof import("${importPath}").${evt.varName}>;`,
                );
            } else {
                eventEntries.push(`                "${evt.id}": unknown;`);
            }
        }

        // Dependencies
        const deps = feature.dependencies ?? [];
        const depsType = deps.length > 0 ? deps.map((d) => `"${d}"`).join(" | ") : "never";

        const svcBody = serviceEntries.length > 0 ? `{\n${serviceEntries.join("\n")}\n            }` : "{}";
        const taskBody = taskEntries.length > 0 ? `{\n${taskEntries.join("\n")}\n            }` : "{}";
        const eventBody = eventEntries.length > 0 ? `{\n${eventEntries.join("\n")}\n            }` : "{}";

        featureBlocks.push(`        "${feature.id}": {
            services: ${svcBody};
            tasks: ${taskBody};
            events: ${eventBody};
            dependencies: ${depsType};
        };`);
    }

    const mapBody = featureBlocks.length > 0 ? `{\n${featureBlocks.join("\n")}\n    }` : "{}";
    const svcOwnerBody = svcOwnerEntries.length > 0 ? `{\n${svcOwnerEntries.join("\n")}\n    }` : "{}";
    const taskOwnerBody = taskOwnerEntries.length > 0 ? `{\n${taskOwnerEntries.join("\n")}\n    }` : "{}";
    const windowMapBlock = generateWindowTypes(windows);

    const content = `${FEATURE_TYPES_HEADER}
declare module "@cordy/electro" {
    interface FeatureMap ${mapBody}

    interface ServiceOwnerMap ${svcOwnerBody}

    interface TaskOwnerMap ${taskOwnerBody}
${windowMapBlock}}
`;

    return { path: "electro-env.d.ts", content };
}

// ── Main generate function ──────────────────────────────────────────

export interface GeneratorInput {
    scanResult: ScanResult;
    windows: readonly WindowDefinition[];
    /** Root output directory (e.g. `.electro/`). Generated files go into `generated/` subdirectory. */
    outputDir: string;
    /** Source directory where `electro-env.d.ts` will be written (e.g. `src/`). */
    srcDir: string;
}

export interface GeneratorOutput {
    /** Files to write into `outputDir` (generated preload scripts, bridge types). */
    files: GeneratedFile[];
    /** Feature registry types file to write into `srcDir`. */
    envTypes: GeneratedFile;
}

/**
 * Generate all output files from scan results and window definitions.
 */
export function generate(input: GeneratorInput): GeneratorOutput {
    const { scanResult, windows, outputDir, srcDir } = input;
    const policy = new PolicyEngine(windows);
    const files: GeneratedFile[] = [];

    for (const win of windows) {
        // Warn on unknown features
        const knownIds = new Set(scanResult.features.map((f) => f.id));
        for (const fId of win.features ?? []) {
            if (!knownIds.has(fId)) {
                console.warn(`[generator] Window "${win.name}" references unknown feature "${fId}"`);
            }
        }

        files.push(generatePreload(win.name, scanResult.features, policy, win.preload));
        files.push(generateBridgeTypes(win.name, scanResult.features, policy));
    }

    const envTypes = generateFeatureTypes(scanResult.features, srcDir, windows);

    return { files, envTypes };
}
