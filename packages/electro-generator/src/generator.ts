/**
 * Code Generator — produces preload scripts, bridge types, and context types.
 *
 * Takes a ScanResult + view definitions and emits generated files.
 * Uses PolicyEngine for deny-by-default per-view filtering.
 */

import { dirname, join, relative } from "node:path";
import type { ViewDefinition } from "@cordy/electro";
import { PolicyEngine } from "@cordy/electro";
import type { GeneratedFile, ScannedFeature, ScannedWindow, ScanResult } from "./types";

// ── Constants ───────────────────────────────────────────────────────

const HEADER = "// Auto-generated by Electro codegen. Do not edit.\n";

/** Quote a property key if it's not a valid JS identifier. */
function q(name: string): string {
    return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name) ? name : `"${name}"`;
}

// ── Preload generator ───────────────────────────────────────────────

/**
 * Build the IPC stub expression for a single method.
 * Format: `(...args: unknown[]) => ipcRenderer.invoke("feature:service:method", ...args)`
 */
function methodStub(featureId: string, serviceId: string, method: string): string {
    const channel = `${featureId}:${serviceId}:${method}`;
    return `(...args: unknown[]) => ipcRenderer.invoke("${channel}", ...args)`;
}

/**
 * Generate a preload script for a specific view.
 *
 * Structure: `window.electro.{featureId}.{serviceId}.{method}()`
 * Only EXPOSED scope services are included.
 */
function generatePreload(
    viewName: string,
    features: ScannedFeature[],
    policy: PolicyEngine,
    preloadExtension?: string,
): GeneratedFile {
    const allowedFeatures = features.filter((f) => policy.canAccess(viewName, f.id));

    // Filter to exposed services only
    const featureEntries: string[] = [];

    for (const feature of allowedFeatures) {
        const exposedServices = feature.services.filter((s) => s.scope === "exposed");
        if (exposedServices.length === 0) {
            // Generate empty namespace for allowed features with no exposed services
            featureEntries.push(`    ${q(feature.id)}: {},`);
            continue;
        }

        const serviceEntries: string[] = [];
        for (const service of exposedServices) {
            if (service.methods.length === 0) {
                serviceEntries.push(`        ${q(service.id)}: {},`);
                continue;
            }
            const methodEntries = service.methods
                .map((m) => `            ${q(m)}: ${methodStub(feature.id, service.id, m)},`)
                .join("\n");
            serviceEntries.push(`        ${q(service.id)}: {\n${methodEntries}\n        },`);
        }

        featureEntries.push(`    ${q(feature.id)}: {\n${serviceEntries.join("\n")}\n    },`);
    }

    // Add events listener when view has allowed features
    if (allowedFeatures.length > 0) {
        featureEntries.push(`    events: {
        on: (channel: string, handler: (...args: unknown[]) => void) => {
            const ipcChannel = \`electro:event:\${channel}\`;
            const listener = (_event: unknown, payload: unknown) => handler(payload);
            ipcRenderer.on(ipcChannel, listener);
            return () => { ipcRenderer.removeListener(ipcChannel, listener); };
        },
    },`);
    }

    const bridgeObject = featureEntries.length > 0 ? `{\n${featureEntries.join("\n")}\n}` : "{}";

    let content = `${HEADER}
import { contextBridge, ipcRenderer } from "electron";

contextBridge.exposeInMainWorld("electro", ${bridgeObject});
`;

    // Append user extension import if specified
    if (preloadExtension) {
        content += `\n// User extension\nimport "${preloadExtension}";\n`;
    }

    return {
        path: `generated/preload/${viewName}.gen.ts`,
        content,
    };
}

// ── Bridge types generator ──────────────────────────────────────────

/**
 * Generate bridge type declarations for a specific view.
 * Makes `window.electro` type-safe in the renderer.
 */
function generateBridgeTypes(view: ViewDefinition, features: ScannedFeature[], policy: PolicyEngine): GeneratedFile {
    const allowedFeatures = features.filter((f) => policy.canAccess(view.name, f.id));
    const bridgeModulePath = join(dirname(view.__source), "bridge.gen.ts");

    const featureTypes: string[] = [];

    for (const feature of allowedFeatures) {
        const exposedServices = feature.services.filter((s) => s.scope === "exposed");
        if (exposedServices.length === 0) {
            featureTypes.push(`        ${q(feature.id)}: Record<string, never>;`);
            continue;
        }

        const serviceTypes: string[] = [];
        for (const service of exposedServices) {
            if (service.exported) {
                const importPath = toImportPathFrom(bridgeModulePath, service.filePath);
                serviceTypes.push(
                    `            ${q(service.id)}: _SvcApi<typeof import("${importPath}").${service.varName}>;`,
                );
            } else {
                serviceTypes.push(`            ${q(service.id)}: unknown;`);
            }
        }

        featureTypes.push(`        ${q(feature.id)}: {\n${serviceTypes.join("\n")}\n        };`);
    }

    // Collect event keys + payload types from allowed features
    const eventTypeEntries: string[] = [];
    for (const feature of allowedFeatures) {
        for (const evt of feature.events ?? []) {
            const eventKey = `${feature.id}:${evt.id}`;
            if (evt.exported) {
                const importPath = toImportPathFrom(bridgeModulePath, evt.filePath);
                eventTypeEntries.push(
                    `    ${JSON.stringify(eventKey)}: _EventPayload<typeof import("${importPath}").${evt.varName}>;`,
                );
            } else {
                eventTypeEntries.push(`    ${JSON.stringify(eventKey)}: unknown;`);
            }
        }
    }

    // Add events type if view has allowed features
    const eventMapTypes =
        eventTypeEntries.length > 0 ? `\ntype ElectroEventMap = {\n${eventTypeEntries.join("\n")}\n};` : "";

    if (allowedFeatures.length > 0) {
        if (eventTypeEntries.length > 0) {
            featureTypes.push(
                `        events: {\n            on<K extends keyof ElectroEventMap>(channel: K, handler: (payload: ElectroEventMap[K]) => void): () => void;\n            on(channel: string & {}, handler: (payload: unknown) => void): () => void;\n        };`,
            );
        } else {
            featureTypes.push(
                `        events: {\n            on(channel: string & {}, handler: (payload: unknown) => void): () => void;\n        };`,
            );
        }
    }

    const interfaceBody = featureTypes.length > 0 ? `{\n${featureTypes.join("\n")}\n    }` : "{}";

    const content = `${HEADER}
type _SvcApi<T> = T extends { api(): infer R } ? NonNullable<R> : never;
type _EventPayload<T> = T extends { payload(): infer P } ? P : unknown;${eventMapTypes}

export interface ElectroBridge ${interfaceBody}
`;

    return {
        path: `generated/views/${view.name}.bridge.d.ts`,
        content,
    };
}

// ── Feature types generator ─────────────────────────────────────────

/** Calculate the import path from the generated env types file to a source file. */
function toImportPathFrom(outputFilePath: string, sourceFilePath: string): string {
    const rel = relative(dirname(outputFilePath), sourceFilePath);
    // Remove .ts extension, ensure starts with . or ..
    const importPath = rel.replace(/\.(?:[cm]?tsx?|[cm]?jsx?)$/, "");
    return importPath.startsWith(".") ? importPath : `./${importPath}`;
}

/** Calculate the import path from the generated env types file to a source file. */
function toImportPath(envTypesDir: string, sourceFilePath: string): string {
    const outputFile = join(envTypesDir, "electro-env.d.ts");
    const rel = relative(dirname(outputFile), sourceFilePath);
    // Remove .ts extension, ensure starts with . or ..
    const importPath = rel.replace(/\.(?:[cm]?tsx?|[cm]?jsx?)$/, "");
    return importPath.startsWith(".") ? importPath : `./${importPath}`;
}

const FEATURE_TYPES_HEADER = `// Auto-generated by Electro codegen. Do not edit.
// Feature context types — provides IDE completions for getService/getTask/getFeature.

export {};

/* ── Utility types ────────────────────────────────────── */
type _SvcApi<T> = T extends { api(): infer R } ? NonNullable<R> : never;
type _TaskPayload<T> = T extends { start(payload?: infer P): any } ? P : void;
type _EventPayload<T> = T extends { payload(): infer P } ? P : unknown;
type _WinApi<T> = T extends { __apiType?: infer A } ? NonNullable<A> : void;
`;

/**
 * Generate ViewMap entries for all defined views.
 * All views use WebContentsView as their type.
 */
function generateViewTypes(views: readonly ViewDefinition[]): string {
    if (views.length === 0) return "";

    const entries: string[] = [];
    for (const view of views) {
        entries.push(`        "${view.name}": import("electron").WebContentsView;`);
    }

    return `\n    interface ViewMap {\n${entries.join("\n")}\n    }\n`;
}

/**
 * Generate WindowApiMap entries for all scanned createWindow() calls.
 * Uses _WinApi utility type to extract the typed API from CreatedWindow<TApi>.
 */
function generateWindowApiTypes(windows: readonly ScannedWindow[], srcDir: string): string {
    if (windows.length === 0) return "";

    const entries: string[] = [];
    for (const win of windows) {
        if (win.exported) {
            const importPath = toImportPath(srcDir, win.filePath);
            entries.push(`        "${win.id}": _WinApi<typeof import("${importPath}").${win.varName}>;`);
        } else {
            entries.push(`        "${win.id}": unknown;`);
        }
    }

    return `\n    interface WindowApiMap {\n${entries.join("\n")}\n    }\n`;
}

function generateFeatureTypes(
    features: ScannedFeature[],
    srcDir: string,
    views: readonly ViewDefinition[],
    windows: readonly ScannedWindow[],
): GeneratedFile {
    const seenFeatures = new Set<string>();
    const featureBlocks: string[] = [];
    const svcOwnerEntries: string[] = [];
    const taskOwnerEntries: string[] = [];

    for (const feature of features) {
        if (seenFeatures.has(feature.id)) {
            console.warn(`[generator] Duplicate feature id "${feature.id}" — first wins`);
            continue;
        }
        seenFeatures.add(feature.id);

        // Services (deduplicate within feature)
        const seenServices = new Set<string>();
        const serviceEntries: string[] = [];
        for (const svc of feature.services) {
            if (seenServices.has(svc.id)) {
                console.warn(`[generator] Duplicate service id "${svc.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenServices.add(svc.id);

            // Owner map entry
            svcOwnerEntries.push(`        "${svc.id}": "${feature.id}";`);

            if (svc.exported) {
                const importPath = toImportPath(srcDir, svc.filePath);
                serviceEntries.push(
                    `                "${svc.id}": _SvcApi<typeof import("${importPath}").${svc.varName}>;`,
                );
            } else {
                serviceEntries.push(`                "${svc.id}": unknown;`);
            }
        }

        // Tasks (deduplicate within feature)
        const seenTasks = new Set<string>();
        const taskEntries: string[] = [];
        for (const task of feature.tasks) {
            if (seenTasks.has(task.id)) {
                console.warn(`[generator] Duplicate task id "${task.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenTasks.add(task.id);

            // Owner map entry
            taskOwnerEntries.push(`        "${task.id}": "${feature.id}";`);

            if (task.exported) {
                const importPath = toImportPath(srcDir, task.filePath);
                taskEntries.push(
                    `                "${task.id}": _TaskPayload<typeof import("${importPath}").${task.varName}>;`,
                );
            } else {
                taskEntries.push(`                "${task.id}": void;`);
            }
        }

        // Events (deduplicate within feature)
        const seenEvents = new Set<string>();
        const eventEntries: string[] = [];
        for (const evt of feature.events ?? []) {
            if (seenEvents.has(evt.id)) {
                console.warn(`[generator] Duplicate event id "${evt.id}" in feature "${feature.id}" — first wins`);
                continue;
            }
            seenEvents.add(evt.id);

            if (evt.exported) {
                const importPath = toImportPath(srcDir, evt.filePath);
                eventEntries.push(
                    `                "${evt.id}": _EventPayload<typeof import("${importPath}").${evt.varName}>;`,
                );
            } else {
                eventEntries.push(`                "${evt.id}": unknown;`);
            }
        }

        // Dependencies
        const deps = feature.dependencies ?? [];
        const depsType = deps.length > 0 ? deps.map((d) => `"${d}"`).join(" | ") : "never";

        const svcBody = serviceEntries.length > 0 ? `{\n${serviceEntries.join("\n")}\n            }` : "{}";
        const taskBody = taskEntries.length > 0 ? `{\n${taskEntries.join("\n")}\n            }` : "{}";
        const eventBody = eventEntries.length > 0 ? `{\n${eventEntries.join("\n")}\n            }` : "{}";

        featureBlocks.push(`        "${feature.id}": {
            services: ${svcBody};
            tasks: ${taskBody};
            events: ${eventBody};
            dependencies: ${depsType};
        };`);
    }

    const mapBody = featureBlocks.length > 0 ? `{\n${featureBlocks.join("\n")}\n    }` : "{}";
    const svcOwnerBody = svcOwnerEntries.length > 0 ? `{\n${svcOwnerEntries.join("\n")}\n    }` : "{}";
    const taskOwnerBody = taskOwnerEntries.length > 0 ? `{\n${taskOwnerEntries.join("\n")}\n    }` : "{}";
    const viewMapBlock = generateViewTypes(views);
    const windowApiMapBlock = generateWindowApiTypes(windows, srcDir);

    const content = `${FEATURE_TYPES_HEADER}
declare module "@cordy/electro" {
    interface FeatureMap ${mapBody}

    interface ServiceOwnerMap ${svcOwnerBody}

    interface TaskOwnerMap ${taskOwnerBody}
${viewMapBlock}${windowApiMapBlock}}
`;

    return { path: "electro-env.d.ts", content };
}

// ── Main generate function ──────────────────────────────────────────

export interface GeneratorInput {
    scanResult: ScanResult;
    views: readonly ViewDefinition[];
    /** Root output directory (e.g. `.electro/`). Generated files go into `generated/` subdirectory. */
    outputDir: string;
    /** Source directory where `electro-env.d.ts` will be written (e.g. `src/`). */
    srcDir: string;
}

export interface GeneratorOutput {
    /** Files to write into `outputDir` (generated preload scripts, bridge types). */
    files: GeneratedFile[];
    /** Feature registry types file to write into `srcDir`. */
    envTypes: GeneratedFile;
}

/**
 * Generate all output files from scan results and view definitions.
 */
export function generate(input: GeneratorInput): GeneratorOutput {
    const { scanResult, views, srcDir } = input;
    const policy = new PolicyEngine(views);
    const files: GeneratedFile[] = [];

    for (const view of views) {
        // Warn on unknown features
        const knownIds = new Set(scanResult.features.map((f) => f.id));
        for (const fId of view.features ?? []) {
            if (!knownIds.has(fId)) {
                console.warn(`[generator] View "${view.name}" references unknown feature "${fId}"`);
            }
        }

        files.push(generatePreload(view.name, scanResult.features, policy, view.preload));
        files.push(generateBridgeTypes(view, scanResult.features, policy));
    }

    const envTypes = generateFeatureTypes(scanResult.features, srcDir, views, scanResult.windows ?? []);

    return { files, envTypes };
}
